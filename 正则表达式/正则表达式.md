<style>
table th:first-of-type {
    width: 50px;
}
</style>

## 前言
正则表达式是个让人又恨又爱的东西，它是一种用于匹配字符串中字符组合的模式。但是如果能够熟练的使用正则表达式的话确实能给日常开发带来很大的便利。

## 基本概念
正则表达式是由一些基本的字符构成的，比如/hello/，或者是简单和特殊字符的组合，比如/[0-9]+/等。因此，我们必须熟记正则表达式中的一些特殊的字符。

### 特殊字符
正则表达式中比较重要的特殊字符表如下

|字符|含义|
|:---:|:---|
|*|前一个表达式出现0次或多次，等价于 {0,}|
|.|除换行符之外的任何单个字符|
|+|前面一个表达式出现1次或者多次，等价于 {1,}|
|?|(1)前面一个表达式出现0次或者1次,等价于 {0,1};<br>(2)如果紧跟在任何量词 *、 +、?和{}的后面，将会使量词变为非贪婪模式，即匹配尽量少的字符（默认使用贪婪模式即匹配尽可能多的字符）。例如，对 "123abc" 应用 /\d+/ 将会返回 "123"，如果使用 /\d+?/,那么就只会匹配到 "1"。|
|{n,m}|n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。|
|[xyz]|表示一个字符集合，而[^xyz]表示一个反向字符集。对于点 . 和星号 * 这样的特殊符号在字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。|
|(x)|匹配 'x' 并且记住匹配项，括号被称为捕获括号。可以用$符号来获取捕获值|
|(?:x)|匹配 'x' 但是不记住匹配项，这种叫作非捕获括号。使得你能够定义为与正则表达式运算符一起使用的子表达式。来看示例表达式 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。|
|x(?=y)|匹配'x'仅仅当'x'后面跟着'y'.这种叫做正向肯定查找。例如，/hello(?=world)/会匹配到'hello'只有当它后面跟着'world',但是‘world’并不是匹配结果的一部分。|
|x(?!y)|匹配'x'仅仅当'x'后面不跟着'y',这个叫做正向否定查找。例如，/\d+(?!\\.)/匹配一个数字仅仅当这个数字后面没有跟小数点的时候。正则表达式/\d+(?!\\.)/.exec("3.141") 匹配“141”但是不是“3.141”|

### 修饰符
正则表达式的修饰符可以说明高级匹配模式的规则，它一共有三个修饰符，具体作用如下表所示

|字符|含义|
|:---:|:---|
|i|执行匹配时不区分大小写|
|g|全局匹配|
|m|多行匹配|

### 匹配方法
javascript中正则表达式匹配方法有RegExp对象中的exec和test方法，以及String对象中的match，replace，search，split方法，它们的具体作用及调用方式如下表

|方法|描述|
|:---:|:---|
|exec|匹配字符串中指定的值，返回找到的值，并确定其位置。不存在则返回null<br> 使用方法：regexp.exec(str)|
|test|匹配字符串中指定的值，存在返回 true 否则 false。<br> 使用方法：regexp.test(str)|
|match|匹配字符串中指定的值，并返回一个数组，其中存放了与它找到的匹配文本有关的信息。如果这个正则表达式没有设置全局搜索，它也会返回一个数组。在这种情况下，数组的第一个元素就是匹配的字符串，余下的元素则是正则表达式中用圆括号括起来的子表达式。因此，如果match返回一个数组arr,那么arr[0]存放的是完整的匹配，arr[1]存放的是与第一个圆括号表达式相匹配的字串，以此类推。<br> 使用方法：str.match(regexp)|
|replace|替换与正则表达式匹配的子串。<br> 使用方法：str.replace(regexp,newStr)|
|search|检索与正则表达式相匹配的值，并返回其第一次在字符串中出现的位置，如果找不到匹配的字串则返回-1。因为search方法会忽略正则表达式中的修饰符g,所以不支持全局检索<br> 使用方法：str.search(regexp)|
|split|把字符串以匹配的规则分割为字符串数组，并返回新数组<br> 使用方法：str.split(regexp)|

### 圆括号
正则表达式中的圆括号()有多种作用：
1.把单独的项组合成子表达式，使得子表达式可以作为一个最小独立单元来进行匹配。比如 /java(script)?/ 可以用来匹配'java'和 'javascript'，但不能匹配javas等其他情况，因为script是一个组合最小匹配单元。

2.在完整的模式中定义子模式。当一个正则表达式跟目标字符串匹配的时候，可以从目标字符串中抽出和圆括号中的子模式相匹配的部分。例如，对于匹配规则 /[a-z]+\d+/，如果我们关心的是后面的数字部分，则可以将其修改为 /[a-z]+(\d+)/,然后使用$1就可以从匹配结果中将数字抽取出来了。

3.允许同一正则表达式的后部引用前面的子表达式。对正则表达式中前一个子模式的引用，并不是指对子表达式模式的引用，而是与那个模式相匹配的文本的引用。它是通过 ‘\’ 后面加一位或者多位数字来实现的，这个数字指定了带圆括号的子表达式在正则表达式中的位置。例如，\1 引用的是第一个圆括号的子表达式，\2 引用的是第二个圆括号的子表达式。由于子表达式可以嵌套另一个子表达式，所以它的位置是参与计数的左括号的位置。

## 正则表达式的应用
正则表达式的应用非常广泛，可以用于字符的预处理，下面主要收集平时中用到的比较有意思的正则表达式的应用实例，不定期更新

```js
/*
*金额格式化：千分符
*/
function formatMoney(val,n) {
    let zs,xs,res;
    let reg = /(\d)(?=(\d{3})+(?!\d))/g;

    if(val.indexOf('.') > -1){
        zs = val.split('.')[0] || '0';
        xs = val.split('.')[1] || '';
    } else {
        zs = val || '0';
        xs = '';
    }
    // 去除整数前面的0
    zs.replace(/^\b(0+)/,"");
    // 默认保留2位小数,最长保留4位
    let len = (n >= 0 && n <= 4) ? n : ((n > 4) ? 4 : 2);
    let zero = '';
    for (let i = 0; i < len; i++){
        zero += '0'
    }
    xs += zero;
    xs = xs.slice(0,len);

    if (len === 0) {
        res = zs.replace(reg,'$1,');
    } else {
        res = zs.replace(reg,'$1,') + '.' + xs;
    }
    return res;
}

/*
*获取百分号前面的数字
*使用先行断言 x(?=y)
*12.3% => 12.3
*/
function rate(str) {
    let reg = /\d*\.\d+(?=%)/
    return str.match(reg)[0]
}
```

## 总结
本文主要记录，总结了正则表达式中的重要知识点。但是光有理论知识还是不够的，只有在平时的开发过程中不断实践，才能够对正则表达式有更深入的理解，体会。

## 参考资料

>1.[正则表达式](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions#special-non-capturing-parentheses)

>2.《JavaScript权威指南》第十章 正则表达式的模式匹配

